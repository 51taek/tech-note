## 복잡한 비즈니스 로직 다루기

### 도메인 모델 (Domain Model)

- 도메인 모델 패턴은 **복잡한 비즈니스 로직을 다루기 위한 패턴**이다.
- 도메인 비즈니스 로직은 이미 본질적으로 복잡하므로,  
  모델을 구성하는 객체가 **여기에 우발적 복잡성(accidental complexity)** 을 추가해서는 안 된다.
- 모델 내부에는 데이터베이스 접근, 외부 시스템 호출과 같은 **기술적 관심사**가 들어오면 안 되며,  
  **순수한 도메인 규칙만**을 담아야 한다.

---

## 도메인 모델의 구성 요소

### 1. 밸류 오브젝트 (Value Object)
- 색(color)처럼 **복합적인 값 자체로 식별되는 객체**
- 문자열 파싱, 유효성 검사, 속성 추출 등 **값에 관한 로직**을 포함할 수 있다
- 가능한 모든 곳에서 적극적으로 사용하는 것이 좋다
- **불변(Immutable)** 이어야 한다

---

### 2. 엔티티 (Entity)
- 엔티티는 **불변이 아니며**, 시간이 지남에 따라 상태가 변한다고 가정한다
- 각 인스턴스는 **고유한 식별자(ID)** 를 가진다  
  → 값이 같아도 ID가 다르면 다른 객체

---

### 3. 애그리게이트 (Aggregate)
- 엔티티보다 더 큰 개념으로,  
  **함께 변경되어야 하는 객체들의 그룹(변경 단위)** 을 의미한다
- 애그리게이트의 로직은 모든 변경 요청을 검사하여  
  **비즈니스 규칙 위반을 방지**해야 한다
- 데이터의 일관성(consistency)은  
  **애그리게이트 루트를 통해서만 상태를 변경하도록 제한**함으로써 보장된다
- 하나의 트랜잭션에는 **하나의 애그리게이트 인스턴스만** 포함되도록 설계해야 한다  
  → 자연스럽게 올바른 경계 설정 가능 (불변성 유지)

#### 💡 애그리게이트 추가 설명
애그리게이트는 **“도메인 모델에서 하나의 변경 단위로 묶여야 하는 객체들의 그룹”**

- **트랜잭션의 최소 단위**
- **일관성(consistency)을 보장하는 단위**

즉, 함께 움직여야 하는 객체들은 하나의 애그리게이트로 묶고  
그 안에 **대표 관리자(Aggregate Root)** 를 둔다.

#### 예시
- **주문(Order)** 과 **주문 항목(OrderLine)** → **같은 애그리게이트**  
  - 이유: 주문 항목이 바뀌면 주문의 총합, 상태 등이 함께 바뀜  
- **사용자(User)** 와 **주문(Order)** → **다른 애그리게이트**  
  - 이유: 둘이 함께 변경될 필요 없음

#### Aggregate로 묶는 기준
1. **A가 변경되면 B의 일관성도 함께 유지되어야 한다**  
2. **B가 변경될 때 A의 일관성이 깨지면 안 된다**

**둘 중 하나라도 만족하면 같은 Aggregate로 묶는다.**

- 강력한 일관성이 필요한 데이터만 애그리게이트에 포함해야 한다
- 반드시 **유비쿼터스 언어(Ubiquitous Language)** 로 모델링해야 한다

---

### 도메인 이벤트 (Domain Event)

- 비즈니스 도메인 관점에서 **중요한 사건을 표현하는 메시지**
- “무엇이 일어났는가?”를 명확하게 서술하는 형태
- 도메인 모델 간 협력을 유도하는 수단

---

### 도메인 서비스 (Domain Service)

- 특정 엔티티나 밸류 오브젝트 단독으로 책임지기 애매한  
  **도메인 비즈니스 로직을 구현하는 상태 없는 객체**
- 예: 여러 애그리게이트에 걸친 계산, 규칙 판단 등

