# 커뮤니케이션 패턴 정리

## 1. 스테이트리스 모델 변환 (Stateless Model Transformation)

프록시 패턴을 사용하여 **수신/발신 요청을 삽입하고**, 소스 모델을 다른 바운디드 컨텍스트의 목표 모델로 매핑한다.

### 동기 방식
- 바운디드 컨텍스트의 코드베이스 내부에 변환 로직을 포함해 구현할 수 있음
- 경우에 따라 API 게이트웨이 같은 **외부 컴포넌트로 변환 로직을 이동**하는 것이 더 효율적일 수 있음
- 여러 버전의 바운디드 컨텍스트 API를 관리하고 제공하기 유리함

### 비동기 방식
- **메시지 프록시**를 통해 구현
- 오픈 호스트 서비스(OHS)를 구현할 때 **비동기 모델 변환은 필수**
- 프라이빗 이벤트 / 퍼블릭 이벤트를 구분하여 처리 가능


---

## 2. 스테이트풀 모델 변환 (Stateful Model Transformation)

- 직접 스테이트풀 모델 변환 솔루션을 구현하는 대신, 다음과 같은 **스트림 처리/배치 처리 플랫폼**을 활용할 수 있다:
  - Kafka, AWS Kinesis
  - Apache NiFi, AWS Glue, Apache Spark


---

## 3. 애그리게이트 연동 (Aggregate Coordination)

- 도메인 이벤트의 동작이 **데이터베이스 상태와 다르게 나타날 수 있음**
- 애그리게이트 연동 시 이벤트 발행 시점과 DB 커밋 시점의 차이를 고려해야 함


---

## 4. 아웃박스 패턴 (Outbox Pattern)

### 알고리즘 흐름
1. 업데이트된 애그리게이트 상태와 **새 도메인 이벤트를 하나의 원자 트랜잭션으로 커밋**
2. 메시지 릴레이가 DB에서 **새로 커밋된 이벤트를 조회**
3. 릴레이가 이벤트를 메시지 버스로 **발행**
4. 발행 성공 시 이벤트 레코드를 **발행 완료로 표시하거나 삭제**

### 세부 내용
- 두 개의 테이블을 원자적으로 커밋할 수 있는 **데이터베이스 기능을 적극 활용**하는 것이 좋음
- 메시지 릴레이는 다음 두 가지 방식 중 하나로 이벤트를 가져올 수 있다:

#### 1) Pull 기반 (Polling)
- 릴레이가 주기적으로 **발행되지 않은 이벤트를 조회**
- 지속적인 질의로 인한 부담을 줄이기 위해 적절한 인덱스 필요

#### 2) Push 기반 (DB 트랜잭션 로그 추적)
- 데이터베이스 트랜잭션 로그를 활용하여 **새 이벤트 삽입 시 즉시 릴레이 호출**
- 일부 DB는 커밋된 변경 사항을 이벤트 스트림 형태로 노출

### 보장
- Outbox 패턴은 **적어도 한 번(at-least-once)** 메시지 전달을 보장한다


---

## 5. 사가 패턴 (Saga Pattern)

- 여러 트랜잭션에 걸친 **분산 비즈니스 프로세스**를 관리
- 핵심 원칙: 각 트랜잭션은 **애그리게이트 하나**에만 영향을 미쳐야 함
- 관련 컴포넌트가 발행한 이벤트를 수신하고, **후속 커맨드를 다른 컴포넌트로 전달**
- 단계 중 하나가 실패할 경우 **보상 트랜잭션(Compensation)** 실행
- 도메인 이벤트를 사용해 **사가 상태 전환을 커맨드 실행과 분리**하여 어느 단계에서 실패해도 안정성 유지


---

## 6. 프로세스 관리자 패턴 (Process Manager)

- 일련의 처리 단계에 대해 **상태를 유지하며 다음 단계를 결정하는 중앙 제어 장치**
- 사가가 if-else로 분기해 행동을 결정하고 있다면 사실상 프로세스 관리자일 가능성이 높다
- 사가는 **암시적으로 인스턴스 생성**, 프로세스 관리자는 **명시적으로 인스턴스 생성**
- 프로세스 관리자는 단일 소스 이벤트에 바인딩될 수 없음


---
