## 아키텍처 패턴

---

## 계층형 아키텍처 (Layered Architecture)

코드베이스를 **수평 계층(Layer)**으로 조직하는 고전적인 구조.

### 프레젠테이션 계층 (Presentation Layer)
- 사용자와 상호작용하는 사용자 인터페이스(UI) 구현
- 과거: 웹 UI, 데스크톱 GUI
- 현대: GUI, CLI, API, 이벤트 발행/구독 인터페이스 등 다양한 방식 포함

### 비즈니스 로직 계층 (Business Logic Layer)
- 프로그램의 코어 비즈니스 로직을 구현하고 도메인 규칙을 처리

### 데이터 접근 계층 (Data Access Layer)
- 데이터베이스 및 영속성 저장소 접근 담당

### 서비스 계층 (Service Layer)
- 비즈니스 로직 계층으로 향하는 진입점 역할
- 하위 계층들을 조합하여 **퍼블릭 인터페이스**(API)에 맞는 메서드 제공
- 여러 퍼블릭 인터페이스에서 동일한 서비스 재사용 가능
- 모듈화 향상 → 관련 기능들이 잘 모여 있고 테스트 용이
- 프레젠테이션 계층과 비즈니스 로직 계층의 결합도 감소

### 계층형 아키텍처를 사용하는 경우
- 비즈니스 로직이 **트랜잭션 스크립트 패턴** 또는 **액티브 레코드 패턴** 기반인 시스템
- 단, **도메인 모델 패턴 기반 시스템**에서는 엔티티(애그리게이트, 밸류 오브젝트)가 인프라스트럭처를 몰라야 하기 때문에  
  계층형 아키텍처 적용이 어려움

---

## 포트와 어댑터 (Ports & Adapters, Hexagonal Architecture)

계층형 아키텍처가 가진 한계를 보완하고, 복잡한 비즈니스 로직을 보다 유연하게 표현하는 구조.

### 핵심 개념
- **비즈니스 로직(도메인)**과 **인프라스트럭처(DB, 외부 API, UI)**의 철저한 분리를 목표로 함
- 비즈니스 로직 계층이 필요한 기능을 “포트(Port)”로 정의
- 인프라스트럭처가 이 포트를 구현한 “어댑터(

## 3. CQRS (Command Query Responsibility Segregation)

명령(Command)과 조회(Query)를 **완전히 분리**하는 아키텍처 패턴.

---

## 3-1. 커맨드 실행 모델 (Command Model)

### 역할
- 시스템의 상태 변경을 전담  
- 비즈니스 규칙 검증  
- 도메인 불변식(invariants) 유지  
- 최신 일관된 상태 유지  
- 낙관적 락 기반 동시성 처리 필요

---

## 3-2. 읽기 모델 (Read Model / Projection)

### 특징
- 조회 전용 모델  
- 필요한 만큼 여러 형태로 생성 가능  
- DB, 캐시, 파일 등 어디에든 저장 가능  
- 커맨드 모델의 변경 사항으로부터 “프로젝션”하여 생성됨

---

## 3-3. 읽기 모델 프로젝션 방식

### 🔹 동기식 프로젝션
- OLTP 데이터의 변경 사항을 직접 구독
- 체크포인트 기반으로 변경을 추적
- 낙관적 락처럼 동작
- 즉각적인 정합성 확보 가능하지만 구현 복잡

### 🔹 비동기식 프로젝션
- 커맨드 모델이 변경 이벤트를 메시지 버스로 발행
- 프로젝션 엔진이 메시지를 구독하여 읽기 모델 갱신
- 메시지 순서 꼬임/중복 처리 시 일관성 문제가 발생
- 기존 프로젝션 재생성 및 신규 프로젝션 추가가 어렵다

---

## 3-4. CQRS 관련 오해와 진실

### ❗ 흔한 오해
> “커맨드는 데이터를 수정만 하고, 조회는 오직 읽기 모델에서만 해야 한다.”

### ✔ 실제로는
- 커맨드도 **실패 여부·실패 이유·결과 데이터를 반환해야 함**
- 읽기 모델이 **궁극적 일관성(Eventual Consistency)** 이므로  
  즉각적인 데이터 갱신을 기대할 수 없음

---

## CQRS가 적합한 경우

- 여러 종류의 저장소(MySQL + Elasticsearch + Redis 등)를 활용해야 하는 경우
- 읽기와 쓰기 성능 요구사항이 완전히 다른 경우
- 대규모 트래픽 환경에서 성능을 극대화해야 할 때
- **이벤트 소싱(Event Sourcing) 기반 시스템**과 자연스럽게 결합됨
