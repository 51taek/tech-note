### 개방-폐쇄 원칙(Open Closed Principle, OCP)

> 소프트웨어 개체(클래스, 모듈, 함수)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
> 
- 확장에 대해 열려있다 → 어플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 어플리케이션의 기능을 확장할 수 있따.
- 수정에 대해 닫혀 있다 → 기존의 ‘코드’를 수정하지 않고도 어플리케이션의 동작을 추가하거나 변경할 수 있따

컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라

개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.

변경에 의한 파급효과를 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야 한다. 추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의깊게 선택했기 때문이다.

### 생성 사용 분리

객체의 타입과 생성자에 전달해야 하는 인자에 대한 과도한 지식은 코드를 특정한 컨텍스트에 강하게 결합시킨다.

유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.

생성과 사용을 분리해야 한다.

사용으로부터 생성을 분리하는 데 가장 보편적인 방버은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.

### 순수한 가공물에게 책임 할당하기

모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도 등 심각한 문제점에 봉착하게 될 가능성이 높아진다. 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 만든 임의의 객체에게 책임을 할당해서 문제를 해결해야 한다.

⇒ 이때 만들어진 도메인과 무관한 인공적인 객체를 순수한 가공물 (PURE FABRICATION) 이라고 부른다.

### 의존성 주입

SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지, 어디에 있는지를 몰라도 되게 해준다.

⇒ 하지만 이 패턴은 의존성을 감춘다는 이유로 별로 좋지 않다

캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다. 단순히 인스턴스 변수의 가시성을 private으로 선언하고 변경되는 내용을 숨겼다고 해서 캡슐화가 지켜지는 것은 아니다.

클래스의 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다. 클래스의 사용법을 익히기 위해서 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.

### 의존성 역전 원칙

요금을 계산하는 상위 정책이 요금을 계산하는 데 필요한 구체적인 방법에 의존하면 안된다.

상위수준의 클래스는 어떤식으로든 하위 수준의 클래스에 의존하면 안된다.

### 유연성에 대한 조언

> 유연한 설계는 우연성이 필요할 때만 옳다
> 

유연한 설계라는 말의 이면에는 복잡한 설계라는 의미가 숨어 있다. 유연한 설계의 양면성은 객관적으로 설계를 판단하기 어렵게 만든다. 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. 아직 일어나지 않은 변경은 변경이 아니다.
