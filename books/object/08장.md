# 의존성 관리하기

협력을 위해서는 의존성이 필요하지만 과도한 의존성은 어플리케이션을 수정하기 어렵게 만든다.

의존성은 실행 시점과 구현 시점에 각각 다른 의미를 가진다.

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

의존성은 전이될 수 있다. 

한 요소가 다른 요소에 직접적으로 의존하면 직접 의존성이고, 전이에 의한 의존이면 간접 의존성이다.

### 의존성 해결하기

컴파일 타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다. ← 의존성 해결

의존성 해결하기 위한 방법

1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결

> 의존성 해결을 위해서 생성자 주입 방법과 setter 주입 방식을 함께 사용하면 좀 더 유연한 설계가 가능하다.
⇒ setter는 절대 쓰면 안될 줄 알았는데 아주 흥미로움. setter는 무조건 나쁘다는 인식을 버려야 할듯.
객체 지향과 관련된 고정관념들을 버려야 할 듯. 타당한 이유가 있는 나만의 주관을 가지는 게 좋아보임.
> 

### 의존성과 결합도

바람직한 의존성은 재사용성과 관련이 있다. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.

특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것 뿐이다.

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.

의존성에 대상을 클래스의 생성자로 받으면 명시적으로 의존성이 노출된다. 하지만 클래스의 내부에서 인스턴스를 직접 생성하는 방식은 의존관계를 감추게 된다. 의존성이 명시적이지 않으면 내부 구현을 살펴볼 수 밖에 없다.

### new는 해롭다.

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 떄문에 결합도가 높아진다.
- new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.

생성자를 통해 이미 만들어진 외부의 인스턴스를 전달받아 의존성을 해결해야 한다.

### 표준 클래스에 대한 의존은 해롭지 않다.

의존성이 불편한 이유는 의존하고 있는 상대가 변경될 수 있기 때문이다. 하지만 JDK에 포함된 표준 클래스라면 변경의 여지가 거의 0에 수렴하므로 이런 클래스에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 변경하더라도 문제가 없다.

⇒ 하지만 이것도 인터페이스로 할 수 있다면 그렇게 하는게 더 좋다
