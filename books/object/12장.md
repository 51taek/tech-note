# 다형성

상속의 목적이 단순히 코드를 재사용하기 위해서라면 상속을 사용하지 말아야 한다.

오버로딩 다형성: 하나의 클래스 안에 동일한 이름의 메서드가 여러개 존재하는 경우

강제 다형성: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식

매개변수 다형성: 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적이 타입으로 지정하는 방식

포함 다형성 (서브타입 다형성): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력.

> 상속의 일차적인 목적이 코드 재사용이 아닌 서브타입의 구현이다.
> 

객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행단위 안으로 통합하는 것이다.

따라서 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다.

### 동적 바인딩

함수를 호출하는 전통적인 언어들은 호출될 함수를 컴파일 타임에 결정한다. 코드 상에서 bar() 함수를 호출하면 실제로 실행되는 코드는 bar() 함수이고 그 외에 어떤 것도 될 수 없다.

하지만, 객체지향 언어에서는 foo.bar() 라는 코드를 사용한다. 이 코드를 읽는 것만으로는 foo 클래스의 bar 메서드인지 foo의 부모 클래스의 bar 메서드인지 알 수가 없다.

이렇게 실행될 메서드를 런타임에 결정하는 방식을 동적 바인딩 or 지연 바인딩 이라고 한다.

메시지를 수신했을 때 실제로 어떤 메시지를 실행할 지 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 통해 결정한다.

### 동적인 문맥

```java
public class Lecture{

	public String methodA(){
		methodB();
		return "hello";
	}
	
	public void methodB(){
		// 동작
	}
}

public class GradeLecture extends Lecture{
	@Override
	public void methodB(){
		// 새로운 동작
	}
}	
```

위와 같은 상황일때 `GradeLecture` 의 `methodB()` 를 호출하면 `Lecture` 의 `methodA()` 가 호출되고 `methodA()` 안에서 실행되는 `methodB()`는 `GradeLecture`의 `methodB()` 를 호출하게 된다.

> super() 는 자기 부모의 함수를 호출하는 것이 아니라. 부모 클래스에서부터 메서드 탐색을 시작하는 것이다. 그러니까 부모의 부모를 탐색할 수도 있다.
> 

**self 참조는 항상 메시지를 수신한 객체를 가리킨다.**

<aside>
💡

객체가 다른 객체에게 요청을 처리할 때 인자로 self를 전달하지 않는 경우를 포워딩.

slef 참조를 전달하는 경우를 위임 이라고 부른다.

위임의 정확한 용도는 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것이다.

</aside>
