# 다형성

상속의 목적이 단순히 코드를 재사용하기 위해서라면 상속을 사용하지 말아야 한다.

오버로딩 다형성: 하나의 클래스 안에 동일한 이름의 메서드가 여러개 존재하는 경우

강제 다형성: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식

매개변수 다형성: 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적이 타입으로 지정하는 방식

포함 다형성 (서브타입 다형성): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력.

> 상속의 일차적인 목적이 코드 재사용이 아닌 서브타입의 구현이다.
> 

객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행단위 안으로 통합하는 것이다.

따라서 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다.

### 동적 바인딩

함수를 호출하는 전통적인 언어들은 호출될 함수를 컴파일 타임에 결정한다. 코드 상에서 bar() 함수를 호출하면 실제로 실행되는 코드는 bar() 함수이고 그 외에 어떤 것도 될 수 없다.

하지만, 객체지향 언어에서는 foo.bar() 라는 코드를 사용한다. 이 코드를 읽는 것만으로는 foo 클래스의 bar 메서드인지 foo의 부모 클래스의 bar 메서드인지 알 수가 없다.

이렇게 실행될 메서드를 런타임에 결정하는 방식을 동적 바인딩 or 지연 바인딩 이라고 한다.

메시지를 수신했을 때 실제로 어떤 메시지를 실행할 지 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 통해 결정한다.
