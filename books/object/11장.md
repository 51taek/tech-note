# 합성과 유연한 설계

합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.

상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.

상속 관계는 is-a관계 라고 부르고 합성 관계는 has-a관계 라고 부른다.

합성을 이용하면 포함된 객체의 내부 구현이 바뀌더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있다.

> 코드 재사용을 위해서라면 합성이 클래스 상속보다 좋은 방법이다.
> 

상속은 부모 클래스 안에 구현된 코드르 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.

상속을 이용하면 모든 조합 가능한 경우의 클래스를 만들어야 한다. 조합 가능한 경우가 많아진다면 클래스 폭발로 이어진다.

컴파일타임 의존성과 런타임 의존성의 거리가 멀수록 설계가 유연해지는데 상속은 컴파일타임 의존성과 런타임 의존성을 동일하게 만드는 것이다.

물론, 컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상승하기 때문에 코드를 이해하기 어려워지는 것도 사실이다.

<aside>
💡

상속을 쓰면 유연성이 줄어들음. 하지만 컴파일타임 의존성과 런타임 의존성이 같기 때문에 코드를 이해하기 쉬워짐. 코드의 복잡도가 줄어들음.

합성을 쓰면 유연성이 커짐. 하지만 코드를 이해하기 어려워짐. 코드의 복잡도가 커짐.

하지만, 합성은 변경에 유리함.

이 둘의 트레이드 오프를 생각하자.

</aside>

### 믹스인

객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법.

합성이 런타임 시점에 객체를 조합하는 재사용방법이라면, 믹스인은 컴파일 ㅅ지ㅓㅁ에 필요한 코드 조각을 조합하는 재사용 방법이다.

상속에 경우에 일반적으로 this 참조는 동적으로 결정되지만 super 참조는 컴파일 시점에 결정된다.

하지만 트레이트에서 super는 동적으로 결정된다. 이것이 믹스인이 더 유연한 재사용 기법인 이유이다.
